.. highlight:: rst

Post-processing
==========================================================


Overview
----------------------------------------
It includes several python scripts for computing the scores and the ranking for a list of clusterings. The format of the input are described in the Clustering Section. More specifically, it includes:

*  Redundancy filtering: for each clustering, it will remove from it all redundant clusters using the algorithm given in the report. For the moment, there is only one redundacy model employed (based on structural similarity)

*  Scoring/Ranking: for each clustering and a given list of measures, it computes the score of this clustering on each of the measure and eventually the rank of this value. Measures values are all real-valued and by default the ranker will treat them as "smaller is better" (favor clusterings with lower value). In any case, one can pass the parameter to change this behavior. 

*  Pareto frontier: it takes a list of clusterings and a list of measures and ouput clusterings that lie on the frontier frontier. 



Output format
----------------------------------------
There are two different file formats generated by this processs. The first one is called ``cluster level` meaning that, like the input format, it is a csv-like where each line describes a cluster (objects, dimensions...), completed by additional measure variables (each one corresponding to a track). The second one is `clustering level` meaning they describe only at clustering level (clustering_id and execution information) plus the measure variables.

The first one is perhapps interesting for visualization since we need the information regarding the composition of each of the clusters but much more heavy in term of size. For statistics tasks, the second one seems more suited.

Redundancy filtering
----------------------------------------
The details about the redundancy employed can be seen in the report. In brief, given 2 clustering A and B, we take for instance A as reference (relevant) clustering and compute the precision of B. 

You can represent code blocks fairly easily::

   precision_score(reference_clustering, target_clustering):
      compute precision


